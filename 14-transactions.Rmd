# Transactions 

## Transaction Concept 
a. `TRANSACTION` - a unit of program execution that accesses and possibly updates various data items. 
      - usually initiated by a data-manipulation language, or programming language w/embedded database accesses
      - transactions are grouped btw function calls, _begin transaction_ and _end transaction_ 
      - one transaction is every step btw the begin and end calls 
      - a transaction must execute in it entirety or not at all 

$$\\[.1cm]$$

b. `ATOMICITY` - this 'all-or-none' property of transaction

c. `ISOLATION` - ensuring that transactions operate properly w/o interference from concurrently executing database statements

d. `DURABILITY` - ensuring that the transaction's actions remain even after system crashes 

e. `CONSISTENCY` - execution of a transaction in isolation preserves the consistency of the database


## A Simple Transaction Model
a. consistency is the responsibility of the application programmer who codes the transaction 

b. atomicity and durability is handled by a component of the database called the recovery system 

c. isolation is maintained by the concurrency-control system component of a databse. 
      - isolation makes sure that concurrenct executions results in  the same resulting state as the end state where all transactions were ran in a serial order, one after another

$$\\[.1cm]$$     

d. types of storage:
      - volatile storage - main memory and cache memory do not usually survive system crashes but has fast access to data 
      - non-volatiel storage - secondary and tertiary storage survives system crashes but has slower access to data 
      - stable storage - storage that replicates info. in several non-volatile disks with independent failure modes; info in stable storage is theoretically _never_ lost 

$$\\[.1cm]$$     

e. for a transaction to be durable, changes need to be written to stable storage 

f. for a transaction to be atomic, log records need to be written to stable storage before any changes are made to database 


## Atomicity and Durability 
a. `ABORTED` - to halt execution of a transcation 

b. `ROLLED BACK` - when changes caused by an aborted transaction have been undone 
      - this is typically done by recovery system and a log 
      - first, record the identifier of the transaction performing the change; the identifier of the data item being modified; the old values; and then the new values
      - after everything is recorded, the database is modified
      
$$\\[.1cm]$$     

c.`COMMITTED` - a successfully execution of a transaction 

d.`COMPENSATING TRANSACTION` - the only way to undo the effects of a committed transaction 
      - not always possible to create such a compensating transaction so usually the user writes and executes a compensating transaction 
      
$$\\[.1cm]$$     

e. a _successful_ execution is one where the transaction enters the committed state and not the other 4 states

<center>
![](images/ch14/state_diagram.png){}

[State diagram of a transaction]()
</center>
$$\\[.1cm]$$
$$\\[.1cm]$$
<center>
![](images/ch14/states.png){}

[State diagram of a transaction]()
</center>

## Isolation 
a. allowing multiple transactions to update data at once can cause consistency problems 

b. but concurrency has two big benefits:
      - Improved throughput and resource utilization - the num. of transactions executed in a given time is higher and the processor and disk spends less time idle 
      - Recudes waiting time - some transactions operate on different parts of the databases and are short, so its better to let them share CPU cycles and disk accesses   
$$\\[.1cm]$$

c. `CONCURRENCY-CONTROL SCHEMES` - variety of mechanism employed by the database system to control the interaction among concurrent transactions and to prevent them from destroying the consistency of the database
      - individually, each transaction may be correct but when ran concurrently, they still can violated the isolation property and cause inconsistency 
      
$$\\[.1cm]$$

d. Schedules - execution sequences that helps identify isolation-abiding transactions and database consistency 

e. Serial v. Concurrent Schedules:
      - serial schedules are one where the instructions belonging to one single transaction appear together in that schedule
      - concurrent schedules are ones where instructions are executed concurrently 
      - Ex. 

<center>
![](images/ch14/schedule1.png){width=25%}

[Schedule 1 - a serial schedule where T1 is followed by T2]()
</center>

$$\\[.1cm]$$

<center>
![](images/ch14/schedule2.png){width=25%}

[Schedule 2 - a serial schedule where T2 is followed by T1]()
</center>

$$\\[.1cm]$$

<center>
![](images/ch14/schedule3.png){width=25%}

[Schedule 3 - a concurrent schedule equivalent to schedule 1]()
</center>

$$\\[.1cm]$$
<center>
![](images/ch14/schedule4.png){width=25%}

[Schedule 4 - a concurrent schedule resulting in an inconsistent state]()
</center>

$$\\[.1cm]$$

f. `SERIALIZABLE` - if a concurrent schedule can be equivalent to s serial schedule 

## Serializability 
a. Different forms of schedule equivalence give rise to
the notions of:
      - conflict serializability
      - view serializability 
      
$$\\[.1cm]$$

b. conflict - two instruction commands are in conflict iff their transactions are different and at least one of the commands is a write(...) instruction

            Ex. 
            1) i = read(Q), j = read(Q). l and j don’t conflict.
            2) i = read(Q), j = write(Q). They conflict.
            3. i = write(Q), j = read(Q). They conflict
            4. i = write(Q), j = write(Q). They conflict

c. If __i__ and __j__ are consecutive instructions are from different transactions and do _not conflict_, we can swap the order of __i__ and __j__ to produce a new schedule 

            Ex. 
            • Swap the read(B) instruction of T1 with the read(A) instruction of T2. 
            • Swap the write(B) instruction of T1 with the write(A) instruction of T2. 
            • Swap the write(B) instruction of T1 with the read(A) instruction of T2.
            
<center>
![](images/ch14/schedule5.png){width=25%}

[Schedule 5 - same as schedule 3 after swapping nonconflicting instructions]()
</center>

$$\\[.1cm]$$

d. 

e. 




